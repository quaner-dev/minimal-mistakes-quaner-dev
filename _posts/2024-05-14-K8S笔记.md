# K8S 笔记

## 第一章 Kubernetes 基础

Kubernetes 是谷歌以 Borg 为前身，基于谷歌 15 年生产环境经验的基础上开源的一个项目，Kubernetes 致力于提供跨主机集群的自动部署、扩展、高可用以及运行应用程序容器的平台。

### 1.1 Master 节点：整个集群的控制中枢

- Kube-APIServer：集群的控制中枢，各个模块之间信息交互都需要经过 Kube-APIServer，同时它也是集群管理、资源配置、整个集群安全机制的入口。
- Controller-Manager：集群的状态管理器，保证 Pod 或其他资源达到期望值，也是需要和 APIServer 进行通信，在需要的时候创建、更新或删除它所管理的资源。
- Scheduler：集群的调度中心，它会根据指定的一系列条件，选择一个或一批最佳的节点，然后部署我们的 Pod。
- Etcd：键值数据库，报错一些集群的信息，一般生产环境中建议部署三个以上节点（奇数个）。

### 1.2 Node：工作节点

#### Worker、node 节点、minion 节点

- Kubelet：负责监听节点上 Pod 的状态，同时负责上报节点和节点上面 Pod 的状态，负责与 Master 节点通信，并管理节点上面的 Pod。
- Kube-proxy：负责 Pod 之间的通信和负载均衡，将指定的流量分发到后端正确的机器上。
- 查看 Kube-proxy 工作模式：curl 127.0.0.1:10249/proxyMode
  - Ipvs：监听 Master 节点增加和删除 service 以及 endpoint 的消息，调用 Netlink 接口创建相应的 IPVS 规则。通过 IPVS 规则，将流量转发至相应的 Pod 上。
  - Iptables：监听 Master 节点增加和删除 service 以及 endpoint 的消息，对于每一个 Service，他都会场景一个 iptables 规则，将 service 的 clusterIP 代理到后端对应的 Pod。

#### 其他组件

- Calico：符合 CNI 标准的网络插件，给每个 Pod 生成一个唯一的 IP 地址，并且把每个节点当做一个路由器。Cilium
- CoreDNS：用于 Kubernetes 集群内部 Service 的解析，可以让 Pod 把 Service 名称解析成 IP 地址，然后通过 Service 的 IP 地址进行连接到对应的应用上。
- Docker：容器引擎，负责对容器的管理。

## 第二章 Pod

### 1.1 什么是 Pod

Pod 是 Kubernetes 中最小的单元，它由一组、一个或多个容器组成，每个 Pod 还包含了一个 Pause 容器，Pause 容器是 Pod 的父容器，主要负责僵尸进程的回收管理，通过 Pause 容器可以使同一个 Pod 里面的多个容器共享存储、网络、PID、IPC 等。

### 1.2 定义一个 Pod

```yaml
apiVersion: v1 # 必选，API的版本号
kind: Pod # 必选，类型Pod
metadata: # 必选，元数据
  name: nginx # 必选，符合RFC 1035规范的Pod名称
  namespace: default # 可选，Pod所在的命名空间，不指定默认为default，可以使用 -n 指定namespace
  labels: # 可选，标签选择器，一般用于过滤和区分Pod
    app: nginx
    role: frontend # 可以写多个
  annotations: # 可选，注释列表，可以写多个
    app: nginx
spec: # 必选，用于定义容器的详细信息
  initContainers: # 初始化容器，在容器启动之前执行的一些初始化操作
    - command:
        - sh
        - -c
        - echo "I am InitContainer for init some configuration"
      image: busybox
      imagePullPolicy: IfNotPresent
      name: init-container
  containers: # 必选，容器列表
    - name: nginx # 必选，符合RFC 1035规范的容器名称
      image: nginx:latest # 必选，容器所用的镜像的地址
      imagePullPolicy: Always # 可选，镜像拉取策略
      command: # 可选，容器启动执行的命令
        - nginx
        - -g
        - "daemon off;"
      workingDir: /usr/share/nginx/html # 可选，容器的工作目录
      volumeMounts: # 可选，存储卷配置，可以配置多个
        - name: webroot # 存储卷名称
          mountPath: /usr/share/nginx/html # 挂载目录
          readOnly: true # 只读
      ports: # 可选，容器需要暴露的端口号列表
        - name: http # 端口名称
          containerPort: 80 # 端口号
          protocol: TCP # 端口协议，默认TCP
      env: # 可选，环境变量配置列表
        - name: TZ # 变量名
          value: Asia/Shanghai # 变量的值
        - name: LANG
          value: en_US.utf8
      resources: # 可选，资源限制和资源请求限制
        limits: # 最大限制设置
          cpu: 1000m
          memory: 1024Mi
        requests: # 启动所需的资源
          cpu: 100m
          memory: 512Mi
      startupProbe: # 可选，检测容器内进程是否完成启动。注意三种检查方式同时只能使用一种。
        httpGet: # httpGet检测方式，生产环境建议使用httpGet实现接口级健康检查，健康检查由应用程序提供。
          path: /api/successStart # 检查路径
          port: 80
      readinessProbe: # 可选，健康检查。注意三种检查方式同时只能使用一种。
        httpGet: # httpGet检测方式，生产环境建议使用httpGet实现接口级健康检查，健康检查由应用程序提供。
          path: / # 检查路径
          port: 80 # 监控端口
      livenessProbe: # 可选，健康检查
        exec: # 执行容器命令检测方式
        command:
          - cat
          - /health
        httpGet: # httpGet检测方式
          path: /_health # 检查路径
          port: 8080
          httpHeaders: # 检查的请求头
            - name: end-user
              value: Jason
        tcpSocket: # 端口检测方式
          port: 80
        initialDelaySeconds: 60 # 初始化时间
        timeoutSeconds: 2 # 超时时间
        periodSeconds: 5 # 检测间隔
        successThreshold: 1 # 检查成功为2次表示就绪
        failureThreshold: 2 # 检测失败1次表示未就绪
      lifecycle:
        postStart: # 容器创建完成后执行的指令, 可以是exec httpGet TCPSocket
          exec:
            command:
              - sh
              - -c
              - "mkdir /data/ "
        preStop:
          httpGet:
            path: /
            port: 80
          exec:
            command:
              - sh
              - -c
              - sleep 9
  restartPolicy: Always # 可选，默认为Always
  nodeSelector: # 可选，指定Node节点
    region: subnet7
  imagePullSecrets: # 可选，拉取镜像使用的secret，可以配置多个
    - name: default-dockercfg-86258
  hostNetwork: false # 可选，是否为主机模式，如是，会占用主机端口
  volumes: # 共享存储卷列表
    - name: webroot # 名称，与上述对应
      emptyDir: {} # 挂载目录
      hostPath: # 挂载本机目录
        path: /etc/hosts
```

### 1.3 Pod 探针

- StartupProbe：k8s1.16 版本后新加的探测方式，用于判断容器内应用程序是否已经启动。如果配置了 startupProbe，就会先禁止其他的探测，直到它成功为止，成功后将不在进行探测。
- LivenessProbe：用于探测容器是否运行，如果探测失败，kubelet 会根据配置的重启策略进行相应的处理。若没有配置该探针，默认就是 success。
- ReadinessProbe：一般用于探测容器内的程序是否健康，它的返回值如果为 success，那么久代表这个容器已经完成启动，并且程序已经是可以接受流量的状态。

### 1.4 Pod 探针的检测方式

- ExecAction：在容器内执行一个命令，如果返回值为 0，则认为容器健康。
- TCPSocketAction：通过 TCP 连接检查容器内的端口是否是通的，如果是通的就认为容器健康。
- HTTPGetAction：通过应用程序暴露的 API 地址来检查程序是否是正常的，如果状态码为 200~400 之间，则认为容器健康。

### 1.5 探针检查参数配置

```yaml
initialDelaySeconds: 60 # 初始化时间
timeoutSeconds: 2 # 超时时间
periodSeconds: 5 # 检测间隔
successThreshold: 1 # 检查成功为1次表示就绪
failureThreshold: 2 # 检测失败2次表示未就绪
```

Prestop：先去请求 eureka 接口，把自己的 IP 地址和端口号，进行下线，eureka 从注册表中删除该应用的 IP 地址。然后容器进行 sleep 90；kill `pgrep java`

## 第三章 RC&RS

### 1.1 Replication Controller 和 ReplicaSet

Replication Controller（复制控制器，RC）和 ReplicaSet（复制集，RS）是两种简单部署 Pod 的方式。因为在生产环境中，主要使用更高级的 Deployment 等方式进行 Pod 的管理和部署，所以本节只对 Replication Controller 和 Replica Set 的部署方式进行简单介绍。

#### 1.1.1 Replication Controller

Replication Controller（简称 RC）可确保 Pod 副本数达到期望值，也就是 RC 定义的数量。换句话说，Replication Controller 可确保一个 Pod 或一组同类 Pod 总是可用。
如果存在的 Pod 大于设定的值，则 Replication Controller 将终止额外的 Pod。如果太小，Replication Controller 将启动更多的 Pod 用于保证达到期望值。与手动创建 Pod 不同的是，用 Replication Controller 维护的 Pod 在失败、删除或终止时会自动替换。因此即使应用程序只需要一个 Pod，也应该使用 Replication Controller 或其他方式管理。Replication Controller 类似于进程管理程序，但是 Replication Controller 不是监视单个节点上的各个进程，而是监视多个节点上的多个 Pod。
定义一个 Replication Controller 的示例如下。

```yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: nginx
spec:
  replicas: 3
  selector:
    app: nginx
  template:
    metadata:
      name: nginx
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx
          ports:
            - containerPort: 80
```

#### 1.1.2 ReplicaSet

ReplicaSet 是支持基于集合的标签选择器的下一代 Replication Controller，它主要用作 Deployment 协调创建、删除和更新 Pod，和 Replication Controller 唯一的区别是，ReplicaSet 支持标签选择器。在实际应用中，虽然 ReplicaSet 可以单独使用，但是一般建议使用 Deployment 来自动管理 ReplicaSet，除非自定义的 Pod 不需要更新或有其他编排等。
定义一个 ReplicaSet 的示例如下：

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: frontend
  labels:
    app: guestbook
    tier: frontend
spec:
  # modify replicas according to your case
  replicas: 3
  selector:
    matchLabels:
      tier: frontend
    matchExpressions:
      - { key: tier, operator: In, values: [frontend] }
  template:
    metadata:
      labels:
        app: guestbook
        tier: frontend
    spec:
      containers:
        - name: php-redis
          image: gcr.io/google_samples/gb-frontend:v3
          resources:
            requests:
              cpu: 100m
              memory: 100Mi
          env:
            - name: GET_HOSTS_FROM
              value: dns
              # If your cluster config does not include a dns service, then to
              # instead access environment variables to find service host
              # info, comment out the 'value: dns' line above, and uncomment the
              # line below.
              # value: env
          ports:
            - containerPort: 80
```

Replication Controller 和 ReplicaSet 的创建删除和 Pod 并无太大区别，Replication Controller 目前几乎已经不在生产环境中使用，ReplicaSet 也很少单独被使用，都是使用更高级的资源 Deployment、DaemonSet、StatefulSet 进行管理 Pod。

## 第四章 Deployment

### 1.1 Deployment 概念

用于部署无状态的服务，这个最常用的控制器。一般用于管理维护企业内部无状态的微服务，比如 configserver、zuul、springboot。他可以管理多个副本的 Pod 实现无缝迁移、自动扩容缩容、自动灾难恢复、一键回滚等功能。

### 1.2 创建一个 Deployment

手动创建：kubectl create deployment nginx --image=nginx:1.15.2
从文件创建：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    deployment.kubernetes.io/revision: "1"
  creationTimestamp: "2020-09-19T02:41:11Z"
  generation: 1
  labels:
    app: nginx
  name: nginx
  namespace: default
spec:
  progressDeadlineSeconds: 600
  replicas: 2 # 副本数
  revisionHistoryLimit: 10 # 历史记录保留的个数
  selector:
    matchLabels:
      app: nginx
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: nginx
    spec:
      containers:
        - image: nginx:1.15.2
          imagePullPolicy: IfNotPresent
          name: nginx
          resources: {}
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
```

状态解析：

```shell
kubectl get deploy -owide
```

- NAME： Deployment 名称
- READY：Pod 的状态，已经 Ready 的个数
- UP-TO-DATE：已经达到期望状态的被更新的副本数
- AVAILABLE：已经可以用的副本数
- AGE：显示应用程序运行的时间
- CONTAINERS：容器名称
- IMAGES：容器的镜像
- SELECTOR：管理的 Pod 的标签

### 1.3 Deployment 的更新

更改 deployment 的镜像并记录：

```shell
kubectl set image deploy nginx nginx=nginx:1.15.3 –record
```

查看更新过程：

```shell
kubectl rollout status deploy nginx
```

或者使用 describe 查看：

```shell
kubectl describe deploy nginx
```

### 1.4 Deployment 回滚

```shell
# 执行更新操作
kubectl set image deploy nginx nginx=nginx:787977da --record
# 查看历史版本
kubectl rollout history deploy nginx
# 回滚到上一个版本
kubectl rollout undo deploy nginx
# 进行多次更新
kubectl set image deploy nginx nginx=nginx:787977da --record
kubectl set image deploy nginx nginx=nginx:787977dadaa --record
kubectl set image deploy nginx nginx=nginx:787977xxxxxdadaa --record
kubectl set image deploy nginx nginx=nginx:787977dadxxxxxdadaa --record
# 查看历史记录
kubectl  rollout history deploy nginx
# 查看指定版本的详细信息
kubectl rollout history deploy nginx --revision=5
# 回滚到执行的版本
kubectl rollout undo deploy nginx --to-revision=5
# 查看deploy状态
kubectl get deploy -oyaml
```

### 1.5 Deployment 的暂停和恢复

```shell
# Deployment 暂停功能
kubectl rollout pause deployment nginx
kubectl set image deploy nginx nginx=nginx:1.15.3 --record
# 进行第二次配置变更
# 添加内存CPU配置
kubectl set resources deploy nginx -c nginx --limits=cpu=200m,memory=128Mi --requests=cpu=10m,memory=16Mi
# 查看pod是否被更新
kubectl get po
kubectl rollout resume deploy nginx
kubectl get rs
```

### 1.6 Deployment 注意事项

```shell
# kubectl get deploy nginx -oyaml
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    deployment.kubernetes.io/revision: "12"
    kubernetes.io/change-cause:
      kubectl set image deploy nginx nginx=nginx:1.15.3
      --record=true
  creationTimestamp: "2020-09-19T02:41:11Z"
  generation: 19
  labels:
    app: nginx
  name: nginx
  namespace: default
spec:
  progressDeadlineSeconds: 600
  replicas: 2
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: nginx
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: nginx
    spec:
      containers:
        - image: nginx:1.15.3
          imagePullPolicy: IfNotPresent
          name: nginx
          resources:
            limits:
              cpu: 200m
              memory: 128Mi
            requests:
              cpu: 10m
              memory: 16Mi
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
```

- spec.revisionHistoryLimit：设置保留 RS 旧的 revision 的个数，设置为 0 的话，不保留历史数据
- spec.minReadySeconds：可选参数，指定新创建的 Pod 在没有任何容器崩溃的情况下视为 Ready 最小的秒数，默认为 0，即一旦被创建就视为可用。
- 滚动更新的策略：
  - spec.strategy.type：更新 deployment 的方式，默认是 RollingUpdate
    - RollingUpdate：滚动更新，可以指定 maxSurge 和 maxUnavailable
      - maxUnavailable：指定在回滚或更新时最大不可用的 Pod 的数量，可选字段，默认 25%，可以设置成数字或百分比，如果该值为 0，那么 maxSurge 就不能 0
      - maxSurge：可以超过期望值的最大 Pod 数，可选字段，默认为 25%，可以设置成数字或百分比，如果该值为 0，那么 maxUnavailable 不能为 0
    - Recreate：重建，先删除旧的 Pod，在创建新的 Pod

## 第五章 Service&Ingress

### 使用 Pod IP 访问应用的问题

Service：
主要用于 Pod 之间的通信，相对于 Pod 的 IP 它创建完成以后就是不变的资源。
Namespace 级别的隔离。

### 最常用的 service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: demo-nginx
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
      name: http
```

### Service 的类型

ClusterIP：在集群内部使用的，默认类型
NodePort：在每个宿主机上暴露一个随机端口，30000-32767，--service-node-port-range，集群外部可访问。
LoadBalancer：使用云服务商提供的 IP 地址。成本太高。
ExternalName：反代到指定的域名上。

没有 Selector 的 service。不会自动创建 EndPoints。
192.168.1.100 3306 没有 selector 的 service 的名字+端口进行访问到 192.168.1.100 3306。
172.16.1.100

ClusterIP+Ingress 域名访问

### Ingress

它是 Kubernetes 集群中服务的入口，可以提供负载均衡、SSL 终止和基于域名的虚拟主机。Treafik、Nginx、HAProxy、Istio。

Ingress 官方文档：https://kubernetes.io/docs/concepts/services-networking/ingress/

Ingress-Nginx 安装文档：https://kubernetes.github.io/ingress-nginx/deploy/

Ingress-Nginx 文档：https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/

定义一个 Ingress：

```yaml
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: simple-fanout-example
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
    - host: foo.bar.com
      http:
        paths:
          - path: /foo
            backend:
              serviceName: service1
              servicePort: 4200
          - path: /bar
            backend:
              serviceName: service2
              servicePort: 8080
```

host: 可选参数，一般都会配置我们自己的域名。
path: 一个路径对应一个 serviceName 和一个 Port
backend: path 对应的后端是谁。
foo.bar.com/foo service1:4200

Ingress：https://kubernetes.io/docs/concepts/services-networking/ingress/

## 第六章 HPA-ConfigMap Secret

HPA
Horizontal Pod Autoscaler：Pod 的水平自动伸缩器。
观察 Pod 的 CPU、内存使用率自动扩展或缩容 Pod 的数量。
不适用于无法缩放的对象，比如 DaemonSet。

    CPU、内存
    自定义指标的扩缩容。

必须定义 Requests 参数，必须安装 metrics-server。

kubectl autoscale deploy demo-nginx --cpu-percent=20 --min=2 --max=5

ConfigMap：
一般用 ConfigMap 去管理一些配置文件、或者一些大量的环境变量信息。

    ConfigMap将配置和Pod分开，有一个nginx，nginx.conf -> configmap,nginx
    更易于配置文件的更改和管理。

    Secret：Secret更倾向于存储和共享敏感、加密的配置信息。

ConfigMap 中文地址：https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-pod-configmap/

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  nodeName: k8s-master02
  containers:
    - name: test-container
      image: busybox:1.28
      imagePullPolicy: IfNotPresent
      command: ["/bin/sh", "-c", "env"]
      envFrom:
        - configMapRef:
            name: special-config
      env:
        # Define the environment variable
        #- name: SPECIAL_LEVEL_KEY
        #  valueFrom:
        #    configMapKeyRef:
        #      # The ConfigMap containing the value you want to assign to SPECIAL_LEVEL_KEY
        #      name: special-config
        #      # Specify the key associated with the value
        #      key: special.how
        - name: test
          value: test-value
        - name: mysqlHostAddress
          value: 10.10.10.10
        - name: mysqlPort
          value: "3306" # only string
  restartPolicy: Never
```

把 ConfigMap 挂载到容器中充当配置文件：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  nodeName: k8s-master02
  containers:
    - name: test-container
      image: busybox:1.28
      imagePullPolicy: IfNotPresent
      command: ["/bin/sh", "-c", "sleep 3600"]
      volumeMounts:
        - name: config-volume
          mountPath: /mnt/1
        - name: contain-filename
          mountPath: /mnt/2
      envFrom:
        - configMapRef:
            name: special-config
      env:
        # Define the environment variable
        #- name: SPECIAL_LEVEL_KEY
        #  valueFrom:
        #    configMapKeyRef:
        #      # The ConfigMap containing the value you want to assign to SPECIAL_LEVEL_KEY
        #      name: special-config
        #      # Specify the key associated with the value
        #      key: special.how
        - name: test
          value: test-value
        - name: mysqlHostAddress
          value: 10.10.10.10
        - name: mysqlPort
          value: "3306" # only string
  restartPolicy: Never
  volumes:
    - name: config-volume
      configMap:
        name: special-config
    - name: contain-filename
      configMap:
        name: game-ui-cm-custom-name
```

Secret：
用来保存敏感信息的，比如密码、令牌或者 Key，Redis、MySQL 密码。

\$ \* \\ 特殊字符单引号无需转义

Secret 用途：
ImagePullSecret：Pod 拉取私有镜像仓库时使用的账户密码，里面的账户信息，会传递给 kubelet，然后 kubelet 就可以拉取有密码的仓库里面的镜像。

创建一个 docker registry 的 secret
[root@k8s-master01 secret]# kubectl create secret docker-registry docker-secret2 --docker-server=hub.docker.com --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL
secret/docker-secret2 created

Secret 中文文档：https://kubernetes.io/zh/docs/concepts/configuration/secret/

subPath 解决目录覆盖的问题：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    deployment.kubernetes.io/revision: "4"
  creationTimestamp: "2020-03-16T14:36:14Z"
  generation: 5
  labels:
    app: demo-nginx
  name: demo-nginx
  namespace: default
  resourceVersion: "1338515"
  selfLink: /apis/apps/v1/namespaces/default/deployments/demo-nginx
  uid: ca0c135f-31a3-464c-b1f2-10f88e9f1c90
spec:
  progressDeadlineSeconds: 600
  replicas: 2
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: demo-nginx
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: demo-nginx
    spec:
      containers:
        - command:
            - sh
            - -c
            - sleep 3600
          image: nginx
          imagePullPolicy: IfNotPresent
          name: nginx
          ports:
            - containerPort: 80
              name: web
              protocol: TCP
          resources:
            limits:
              cpu: 100m
              memory: 270Mi
            requests:
              cpu: 100m
              memory: 70Mi
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          volumeMounts:
            - mountPath: /etc/nginx/nginx.conf
              name: config-volume
              subPath: etc/nginx/nginx.conf
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
      volumes:
        - configMap:
            defaultMode: 420
            items:
              - key: nginx.conf
                path: etc/nginx/nginx.conf
            name: nginx-conf
          name: config-volume
```

ConfigMap 和 Secret 如果是以 subPath 的形式挂载的，那么 Pod 是不会感知到 ConfigMap 和 Secret 的更新的。
如果 Pod 的变量来自于 ConfigMap 和 Secret 中定义的内容，那么 ConfigMap 和 Secret 更新后，也不会更新 Pod 中的变量。

postStart：容器启动之前执行的命令
preStop：容器停止之前执行的命令

热更新 ConfigMap 或 Secret：
[root@k8s-master01 ~]# kubectl create cm nginx-conf --from-file=nginx.conf --dry-run -oyaml | kubectl replace -f-
